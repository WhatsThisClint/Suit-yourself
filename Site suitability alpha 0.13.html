<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Suitability Analyzer</title>
    
    <!-- Leaflet CSS Library -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- All Application Styles -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #333;
        }

        .container {
            display: flex;
            height: 100%;
            width: 100%;
        }

        #left-sidebar {
            width: 25%;
            max-width: 350px;
            min-width: 280px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            z-index: 1001;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
            flex-wrap: wrap; 
        }

        #left-sidebar h2 {
            margin: 0;
            color: #212529;
            flex-shrink: 0;
        }
        .header-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            margin-top: 10px;
        }

        .action-button {
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            white-space: nowrap;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
        }
        #analyze-button { background-color: #4f46e5; }
        #insights-button { background-color: #17a2b8; }

        .action-button:hover { opacity: 0.8; }
        .action-button:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        .file-input-label {
            display: block;
            margin-bottom: 10px;
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
            background-color: #6c757d;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s ease;
        }
        .file-input-label:hover { background-color: #5a6268; }
        .file-input { display: none; }
        
        #file-name-display, #location-file-display {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: -5px;
            margin-bottom: 15px;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #map { flex-grow: 1; height: 100%; background-color: #e9ecef; }
        
        #stats-panel {
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: #e9ecef;
            margin-top: 20px;
        }
        #stats-panel h3 {
            margin-top: 0;
            font-size: 1.1em;
            border-bottom: 1px solid #ced4da;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            padding: 4px 0;
            cursor: pointer;
            border-left: 4px solid transparent;
            padding-left: 10px;
            margin-left: -10px;
            transition: background-color 0.2s, border-left-color 0.2s;
        }
        .stats-row:hover { background-color: #dcdcdc; }
        .stats-row.active { border-left-color: #007bff; background-color: #d4eaff; }
        .stats-label { font-weight: bold; }
        .stats-value { padding: 2px 8px; border-radius: 10px; color: #fff; }
        .stats-total { background-color: #6c757d; }
        .stats-unvalidated { background-color: #007bff; }
        .stats-green { background-color: #28a745; }
        .stats-amber { background-color: #ffc107; color: #212529; }
        .stats-red { background-color: #dc3545; }
        .stats-not-required { background-color: #adb5bd; }
        
        #next-unchecked-btn { width: 100%; margin-top: 10px; }

        #right-sidebar {
            width: 25%;
            max-width: 350px;
            min-width: 280px;
            padding: 20px;
            box-sizing: border-box;
            background-color: #f8f9fa;
            border-left: 1px solid #dee2e6;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            z-index: 1001;
        }
        #right-sidebar.hidden { transform: translateX(100%); min-width: 0; width: 0; padding: 20px 0; }
        #info-panel { padding: 15px; border: 1px solid #dee2e6; border-radius: 4px; background-color: #ffffff; }
        #info-panel h3 { margin-top: 0; font-size: 1.1em; border-bottom: 1px solid #e9ecef; padding-bottom: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        #info-panel-close { cursor: pointer; font-size: 1.4em; font-weight: bold; color: #6c757d; border: none; background: none; padding: 0 5px; }
        #info-panel-close:hover { color: #212529; }
        #info-panel-content { font-size: 0.9em; word-wrap: break-word; }
        .stacked-point-header { font-weight: bold; background-color: #e9ecef; padding: 5px; margin-top: 15px; border-radius: 3px; }
        #info-panel-content strong { display: inline-block; min-width: 80px; color: #495057; }
        .editable-field { width: calc(100% - 90px); padding: 4px; border: 1px solid #ced4da; border-radius: 3px; }
        .rag-selector { margin-top: 15px; padding-top: 15px; border-top: 1px solid #e9ecef; display: flex; justify-content: space-around; flex-wrap: wrap; gap: 5px;}
        .rag-button { cursor: pointer; padding: 8px 12px; border: 2px solid transparent; border-radius: 20px; font-weight: bold; color: #fff; transition: transform 0.1s ease-in-out, border-color 0.2s; }
        .rag-button:hover { transform: scale(1.05); }
        .rag-button.selected { border-color: #212529; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .rag-green { background-color: #28a745; }
        .rag-amber { background-color: #ffc107; color: #212529; }
        .rag-red { background-color: #dc3545; }
        .rag-not-required { background-color: #6c757d; }
        
        .loader-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10000; }
        .loader-spinner { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1.5s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #toast-container { position: fixed; top: 20px; right: 80px; z-index: 10001; display: flex; flex-direction: column; align-items: flex-end; }
        .toast { background-color: #333; color: #fff; padding: 12px 20px; border-radius: 5px; margin-bottom: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.3s, transform 0.3s; transform: translateY(-20px); }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { background-color: #dc3545; }
        .toast.success { background-color: #28a745; }

        .hidden { display: none !important; }
        .leaflet-control-layers-overlays label { display: flex; align-items: center; }
        .layer-style-icon { cursor: pointer; margin-left: 8px; font-style: normal; }
        .layer-style-icon:hover { transform: scale(1.2); }

        /* Modal Styles */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10002; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: #fff; padding: 25px; border-radius: 12px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e7eb; padding-bottom: 10px; margin-bottom: 15px; }
        .modal-header h2 { margin: 0; font-size: 1.3em; color: #111827; }
        .modal-close { font-size: 1.8em; font-weight: bold; color: #6b7280; cursor: pointer; border: none; background: none; }
        #analysis-result, #style-editor-body, #field-config-body { font-size: 1em; line-height: 1.6; color: #374151; }
        .style-control, .field-config-row { margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        .field-config-row { justify-content: space-between; }
        .field-config-row .field-name { font-weight: bold; word-break: break-all; }
        .field-config-row .checkboxes { display: flex; gap: 15px; flex-shrink: 0; }
        .style-control label { font-weight: bold; }
        .field-config-header { display: flex; justify-content: flex-end; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e5e7eb; }
        .select-all-link { font-size: 0.8em; cursor: pointer; color: #007bff; text-decoration: underline; }
        
        /* Dashboard View Styles */
        #dashboard-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f2f5;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #dashboard-header {
            background-color: #fff;
            padding: 15px 25px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        #dashboard-header h2 {
            margin: 0;
            font-size: 1.5em;
            color: #333;
        }
        #dashboard-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label { font-weight: bold; }
        #dashboard-controls select, #dashboard-controls .action-button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            height: 38px;
            box-sizing: border-box;
        }
        #generate-chart-btn {
            background-color: #28a745;
        }
        #back-to-map-btn {
            background-color: #6c757d;
            margin-left: auto;
        }
        #chart-grid {
            flex-grow: 1;
            padding: 25px;
            display: grid;
            gap: 25px;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            overflow-y: auto;
        }
        .chart-card {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .chart-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
        }
        .chart-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
        }
        .chart-card-header h3 {
            margin: 0;
            font-size: 1.1em;
            word-break: break-word;
        }
        .remove-chart-btn {
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1.2em;
            color: #6c757d;
            flex-shrink: 0;
            margin-left: 10px;
        }
        .remove-chart-btn:hover { color: #dc3545; }
        .chart-canvas-container {
            position: relative;
            flex-grow: 1;
            min-height: 300px;
        }
    </style>
</head>
<body>
    <div id="loader" class="loader-container hidden">
        <div class="loader-spinner"></div>
        <p id="loader-text">Loading...</p>
    </div>

    <div id="toast-container"></div>
    
    <div id="analysis-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🗺️ AI Map Analysis</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div id="analysis-result"></div>
        </div>
    </div>

    <div id="style-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="style-editor-title">Style Layer</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div id="style-editor-body">
                <div class="style-control">
                    <label for="layer-color-picker">Color:</label>
                    <input type="color" id="layer-color-picker">
                </div>
                <div class="style-control">
                    <label for="layer-opacity-slider">Opacity:</label>
                    <input type="range" id="layer-opacity-slider" min="0" max="1" step="0.1">
                </div>
                <button id="apply-style-button" class="action-button">Apply Style</button>
            </div>
        </div>
    </div>

    <div id="field-config-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Configure Display Fields</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div id="field-config-body">
                <!-- Field rows will be inserted here by JS -->
            </div>
        </div>
    </div>

    <div class="container">
        <div id="left-sidebar">
            <div class="sidebar-header">
                <h2>Site Suitability Analyzer</h2>
            </div>
            
            <p>1. Select location file (.xlsx, .xls, .csv):</p>
            <label for="location-file-input" class="file-input-label">Select Location File</label>
            <input type="file" id="location-file-input" class="file-input" accept=".xlsx,.xls,.csv">
            <div id="location-file-display">No location file selected.</div>
            <button id="plot-button" class="action-button" disabled>Plot Data</button>

            <button id="config-fields-button" class="action-button hidden" style="margin-top: 10px;">Configure Fields</button>

            <p style="margin-top: 20px;">2. Add vector layers (.geojson):</p>
            <label for="geojson-file-input" class="file-input-label">Add GeoJSON Layer</label>
            <input type="file" id="geojson-file-input" class="file-input" accept=".geojson,.json" multiple>
            
            <div class="header-buttons">
                <button id="analyze-button" class="action-button" title="Use AI to analyze the visible map area">Analyze Map</button>
                <button id="insights-button" class="action-button" title="Get insights from your data">Data Insights</button>
                <button id="export-csv" class="action-button">Export CSV</button>
            </div>

            <div id="stats-panel"></div>
        </div>
        
        <div id="map"></div>

        <div id="right-sidebar" class="hidden">
            <div id="info-panel"></div>
        </div>
    </div>

    <div id="dashboard-view" class="hidden">
        <div id="dashboard-header">
            <h2>Analytics Dashboard</h2>
            <div id="dashboard-controls">
                <div class="control-group">
                    <label for="dimension-select">Group By:</label>
                    <select id="dimension-select"></select>
                </div>
                <div class="control-group">
                    <label for="segment-select">Segment By:</label>
                    <select id="segment-select"></select>
                </div>
                <div class="control-group">
                    <label for="chart-type-select">Chart Type:</label>
                    <select id="chart-type-select">
                        <option value="bar">Bar</option>
                        <option value="stacked-bar">Stacked Bar</option>
                        <option value="pie">Pie</option>
                        <option value="doughnut">Doughnut</option>
                    </select>
                </div>
                <button id="generate-chart-btn" class="action-button" style="width:auto;">Generate Chart</button>
            </div>
            <button id="back-to-map-btn" class="action-button" style="width:auto;">Back to Map</button>
        </div>
        <div id="chart-grid"></div>
    </div>

    <!-- Core Libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


    <!-- All Application JavaScript -->
    <script type="module">
        // --- state.js ---
        const State = (() => {
            let points = [];
            let rawLocationData = null;
            let currentIndex = -1;
            let locationFile = null;
            let fieldConfig = null;
            let currentFilter = 'All';

            return {
                setPoints: (newPoints) => { points = newPoints; currentIndex = -1; },
                getPoints: () => points,
                getPointById: (id) => points.find(p => p.id === id),
                updatePointStatus: (id, newStatus) => { const point = points.find(p => p.id === id); if (point) point.ragStatus = newStatus; },
                updatePointData: (pointId, recordIndex, key, value) => {
                    const point = points.find(p => p.id === pointId);
                    if (point && point.originalData[recordIndex]) {
                        point.originalData[recordIndex][key] = value;
                    }
                },
                setRawLocationData: (data) => { rawLocationData = data; },
                getRawLocationData: () => rawLocationData,
                findNextUnvalidated: () => {
                    const currentPoint = points[currentIndex];
                    let nextIndex = -1;
                    if (currentPoint) {
                        for (let i = currentIndex + 1; i < points.length; i++) { if (points[i].ragStatus === 'Unvalidated') { nextIndex = i; break; } }
                    }
                    if (nextIndex === -1) { nextIndex = points.findIndex(p => p.ragStatus === 'Unvalidated'); }
                    if (nextIndex !== -1) { currentIndex = nextIndex; return points[nextIndex]; }
                    return null;
                },
                setCurrentIndexById: (id) => { currentIndex = points.findIndex(p => p.id === id); },
                getCurrentIndex: () => currentIndex,
                setLocationFile: (file) => { locationFile = file; },
                getLocationFile: () => locationFile,
                setFieldConfig: (config) => { fieldConfig = config; },
                getFieldConfig: () => fieldConfig,
                setCurrentFilter: (filter) => { currentFilter = filter; },
                getCurrentFilter: () => currentFilter,
            };
        })();

        // --- dataParser.js ---
        const DataParser = (() => {
            return {
                parseLocationData: (jsonData) => {
                    if (!jsonData || jsonData.length === 0) return null;
                    const uniqueLocations = new Map();
                    const firstRowKeys = Object.keys(jsonData[0]);
                    const latKey = firstRowKeys.find(k => k.toLowerCase().trim().match(/^(lat|latitude)$/));
                    const lonKey = firstRowKeys.find(k => k.toLowerCase().trim().match(/^(lon|long|longitude)$/));

                    if (!latKey || !lonKey) {
                        UIController.showToast("Latitude or Longitude columns not found in file.", "error");
                        return null;
                    }
                    
                    const validStatuses = ['Green', 'Amber', 'Red', 'Unvalidated', 'Not Required'];

                    jsonData.forEach((row) => {
                        if (!row.hasOwnProperty('User_Comment')) {
                            row['User_Comment'] = '';
                        }
                        const ragStatus = row.hasOwnProperty('validation_status') && validStatuses.includes(row.validation_status)
                            ? row.validation_status
                            : 'Unvalidated';

                        const lat = parseFloat(row[latKey]);
                        const lon = parseFloat(row[lonKey]);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                            if (uniqueLocations.has(coordKey)) {
                                uniqueLocations.get(coordKey).originalData.push(row);
                            } else {
                                uniqueLocations.set(coordKey, {
                                    id: `point-${uniqueLocations.size}`, latitude: lat, longitude: lon,
                                    ragStatus: ragStatus, originalData: [row], mapMarker: null
                                });
                            }
                        } else { console.warn(`Skipping row due to invalid lat/lon.`, row); }
                    });
                    return Array.from(uniqueLocations.values());
                }
            };
        })();
        
        // --- AnalyticsController.js ---
        const AnalyticsController = (() => {
            const activeCharts = new Map();

            const generateRandomColors = (numColors) => {
                const colors = [];
                for (let i = 0; i < numColors; i++) {
                    const r = Math.floor(Math.random() * 200);
                    const g = Math.floor(Math.random() * 200);
                    const b = Math.floor(Math.random() * 200);
                    colors.push(`rgba(${r}, ${g}, ${b}, 0.7)`);
                }
                return colors;
            };

            const getOrCreate = (map, key, factory) => {
                if (!map.has(key)) {
                    map.set(key, factory());
                }
                return map.get(key);
            };

            return {
                createChart: (canvas, data, dimensionCol, segmentCol, chartType) => {
                    const ctx = canvas.getContext('2d');
                    let chartConfig;

                    if (segmentCol === 'none') {
                        // Simple chart (Bar, Pie, Doughnut)
                        const counts = {};
                        data.forEach(row => {
                            const value = row[dimensionCol] === null || row[dimensionCol] === undefined ? 'N/A' : String(row[dimensionCol]);
                            counts[value] = (counts[value] || 0) + 1;
                        });

                        const labels = Object.keys(counts);
                        const values = Object.values(counts);
                        const colors = generateRandomColors(labels.length);

                        chartConfig = {
                            type: chartType === 'stacked-bar' ? 'bar' : chartType, // fallback for simple chart
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: `Count of ${dimensionCol}`,
                                    data: values,
                                    backgroundColor: colors,
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: chartType === 'bar' ? 'none' : 'top',
                                    }
                                }
                            }
                        };

                    } else {
                        // Segmented / Stacked Bar Chart
                        const nestedData = new Map();
                        const segmentLabels = new Set();

                        data.forEach(row => {
                            const dimValue = row[dimensionCol] === null || row[dimensionCol] === undefined ? 'N/A' : String(row[dimensionCol]);
                            const segValue = row[segmentCol] === null || row[segmentCol] === undefined ? 'N/A' : String(row[segmentCol]);
                            segmentLabels.add(segValue);

                            const dimMap = getOrCreate(nestedData, dimValue, () => new Map());
                            const segCount = getOrCreate(dimMap, segValue, () => 0);
                            dimMap.set(segValue, segCount + 1);
                        });

                        const dimensionLabels = Array.from(nestedData.keys());
                        const sortedSegmentLabels = Array.from(segmentLabels).sort();
                        const colors = generateRandomColors(sortedSegmentLabels.length);
                        const colorMap = new Map(sortedSegmentLabels.map((label, i) => [label, colors[i]]));

                        const datasets = sortedSegmentLabels.map(segLabel => {
                            return {
                                label: segLabel,
                                data: dimensionLabels.map(dimLabel => nestedData.get(dimLabel).get(segLabel) || 0),
                                backgroundColor: colorMap.get(segLabel),
                            };
                        });
                        
                        chartConfig = {
                            type: 'bar',
                            data: {
                                labels: dimensionLabels,
                                datasets: datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: { stacked: true },
                                    y: { stacked: true, beginAtZero: true }
                                },
                                plugins: {
                                    legend: { position: 'top' }
                                }
                            }
                        };
                    }

                    const newChart = new Chart(ctx, chartConfig);
                    activeCharts.set(canvas.id, newChart);
                    return true;
                },
                removeChart: (canvasId) => {
                    if (activeCharts.has(canvasId)) {
                        activeCharts.get(canvasId).destroy();
                        activeCharts.delete(canvasId);
                    }
                },
                clearAllCharts: () => {
                    activeCharts.forEach(chart => chart.destroy());
                    activeCharts.clear();
                }
            };
        })();

        // --- exporter.js ---
        const Exporter = (() => {
            return {
                exportToCSV: (points) => {
                    if (!points || points.length === 0) return;
                    const dataForCSV = [];
                    points.forEach(point => {
                        point.originalData.forEach(originalRow => {
                            dataForCSV.push({ ...originalRow, validation_status: point.ragStatus });
                        });
                    });
                    const csv = Papa.unparse(dataForCSV);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = "site_suitability_report.csv";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };
        })();

        // --- mapView.js ---
        const MapView = (() => {
            let pointLayerGroup = null;
            let layerControl = null; 
            let geojsonLayers = new Map();
            const createIcon = (color, isSelected = false, stackCount = 1) => {
                const size = isSelected ? 38 : 28;
                const strokeWidth = isSelected ? 2 : 1;
                const badgeHtml = stackCount > 1 ? `<circle cx="20" cy="4" r="4" fill="red"/><text x="20" y="5.5" font-family="Arial" font-size="6" fill="white" text-anchor="middle">${stackCount}</text>` : '';
                const markerHtml = `<svg viewBox="0 0 24 24" width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="${color}" stroke="#000" stroke-width="${strokeWidth}"/>${badgeHtml}</svg>`;
                return L.divIcon({ html: markerHtml, className: '', iconSize: [size, size], iconAnchor: [size/2, size], popupAnchor: [0, -size] });
            };
            const iconColors = {
                Unvalidated: '#007BFF',
                Green: '#28a745',
                Amber: '#ffc107',
                Red: '#dc3545',
                'Not Required': '#6c757d'
            };
            const generateIcons = (stackCount) => ({
                Unvalidated: createIcon(iconColors.Unvalidated, false, stackCount),
                Green: createIcon(iconColors.Green, false, stackCount),
                Amber: createIcon(iconColors.Amber, false, stackCount),
                Red: createIcon(iconColors.Red, false, stackCount),
                'Not Required': createIcon(iconColors['Not Required'], false, stackCount)
            });
            const generateSelectedIcons = (stackCount) => ({
                Unvalidated: createIcon(iconColors.Unvalidated, true, stackCount),
                Green: createIcon(iconColors.Green, true, stackCount),
                Amber: createIcon(iconColors.Amber, true, stackCount),
                Red: createIcon(iconColors.Red, true, stackCount),
                'Not Required': createIcon(iconColors['Not Required'], true, stackCount)
            });
            let selectedMarker = null;

            const _updateAllStyleIcons = () => {
                const container = layerControl.getContainer();
                if (!container) return;
                const overlays = container.querySelector('.leaflet-control-layers-overlays');
                const labels = overlays.getElementsByTagName('label');
                for (const label of labels) {
                    const span = label.querySelector('span');
                    if (span) {
                        const layerName = span.textContent.trim();
                        if (geojsonLayers.has(layerName)) {
                            const existingIcon = span.querySelector('.layer-style-icon');
                            if (!existingIcon) {
                                const styleIcon = document.createElement('i');
                                styleIcon.className = 'layer-style-icon';
                                styleIcon.innerHTML = '🎨';
                                styleIcon.dataset.layerName = layerName;
                                span.appendChild(styleIcon);
                            }
                        }
                    }
                }
            };

            return {
                initializeMap: () => {
                    const map = L.map('map').setView([20.5937, 78.9629], 5);
                    
                    const baseLayers = {
                        "Street": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors' }).addTo(map),
                        "Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' }),
                        "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>' }),
                        "Esri World Topo": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, and the GIS User Community' })
                    };
                    const overlayLayers = { "Hillshade": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri', opacity: 0.65 }) };
                    layerControl = L.control.layers(baseLayers, overlayLayers, { position: 'topright' }).addTo(map);
                    pointLayerGroup = L.featureGroup().addTo(map);
                    
                    map.on('overlayadd overlayremove', _updateAllStyleIcons);

                    return map;
                },
                addGeoJsonLayer: (map, geoJsonData, layerName) => {
                    try {
                        const defaultStyle = { color: "#ff7800", weight: 2, opacity: 1, fillOpacity: 0.5 };
                        const geoJsonLayer = L.geoJSON(geoJsonData, { style: defaultStyle });
                        
                        geojsonLayers.set(layerName, geoJsonLayer);
                        layerControl.addOverlay(geoJsonLayer, layerName);
                        geoJsonLayer.addTo(map);

                        setTimeout(_updateAllStyleIcons, 100);
                        
                        UIController.showToast(`Layer "${layerName}" added.`, 'success');
                    } catch (error) {
                        console.error("Error adding GeoJSON layer:", error);
                        UIController.showToast(`Failed to add layer: ${layerName}`, 'error');
                    }
                },
                updateGeoJsonStyle: (layerName, newStyle) => {
                    if (geojsonLayers.has(layerName)) {
                        const layer = geojsonLayers.get(layerName);
                        layer.setStyle(newStyle);
                        layer.options.style = newStyle;
                    }
                },
                getGeoJsonLayerStyle: (layerName) => {
                    if (geojsonLayers.has(layerName)) {
                        const layer = geojsonLayers.get(layerName);
                        return layer.options.style;
                    }
                    return { color: '#ff7800', opacity: 1, fillOpacity: 0.5 };
                },
                plotPoints: (map, pointsData, onMarkerClick) => {
                    pointLayerGroup.clearLayers();
                    selectedMarker = null;
                    pointsData.forEach(point => {
                        const stackCount = point.originalData.length;
                        const marker = L.marker([point.latitude, point.longitude], { icon: generateIcons(stackCount)[point.ragStatus] });
                        marker.pointId = point.id;
                        marker.on('click', () => onMarkerClick(marker.pointId));
                        point.mapMarker = marker;
                        pointLayerGroup.addLayer(marker);
                    });
                    if (pointsData.length > 0) {
                         map.fitBounds(pointLayerGroup.getBounds().pad(0.1));
                    }
                },
                updateMarker: (marker, newStatus, isSelected, stackCount) => {
                    if (!marker) return;
                    const iconSet = isSelected ? generateSelectedIcons(stackCount) : generateIcons(stackCount);
                    if (iconSet[newStatus]) marker.setIcon(iconSet[newStatus]);
                },
                panToPoint: (map, point) => { if (point) map.panTo([point.latitude, point.longitude]); },
                setSelectedMarker: (point) => {
                    if (selectedMarker) {
                        const oldPoint = State.getPointById(selectedMarker.pointId);
                        if (oldPoint) MapView.updateMarker(selectedMarker, oldPoint.ragStatus, false, oldPoint.originalData.length);
                    }
                    selectedMarker = point.mapMarker;
                    MapView.updateMarker(selectedMarker, point.ragStatus, true, point.originalData.length);
                },
                getGeoJsonLayer: (layerName) => geojsonLayers.get(layerName)
            };
        })();

        // --- uiController.js ---
        const UIController = (() => {
            const container = document.querySelector('.container');
            const dashboardView = document.getElementById('dashboard-view');
            const locationFileInput = document.getElementById('location-file-input');
            const geoJsonFileInput = document.getElementById('geojson-file-input'); 
            const plotButton = document.getElementById('plot-button');
            const rightSidebar = document.getElementById('right-sidebar');
            const infoPanel = document.getElementById('info-panel');
            const statsPanel = document.getElementById('stats-panel');
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loader-text');
            const styleModal = document.getElementById('style-editor-modal');
            const fieldConfigModal = document.getElementById('field-config-modal');
            
            let chartIdCounter = 0;

            return {
                initializeUI: (callbacks) => {
                    document.getElementById('export-csv').addEventListener('click', callbacks.onExportClick);
                    document.getElementById('analyze-button').addEventListener('click', callbacks.onAnalyzeClick);
                    document.getElementById('insights-button').addEventListener('click', callbacks.onInsightsClick);
                    document.getElementById('config-fields-button').addEventListener('click', callbacks.onConfigFieldsClick);
                    locationFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { document.getElementById('location-file-display').textContent = file.name; callbacks.onLocationFileSelect(file); } });
                    geoJsonFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) { callbacks.onGeoJsonFileSelect(e.target.files); e.target.value = ''; } }); 
                    plotButton.addEventListener('click', callbacks.onPlotClick);
                    statsPanel.addEventListener('click', (e) => { 
                        if (e.target && e.target.closest('.stats-row')) {
                            const status = e.target.closest('.stats-row').dataset.status;
                            if (status) callbacks.onStatusFilterClick(status);
                        }
                        if (e.target && e.target.id === 'next-unchecked-btn') callbacks.onNextUncheckedClick();
                    });
                    
                    const layerControlContainer = document.querySelector('.leaflet-control-layers');
                    if (layerControlContainer) {
                        layerControlContainer.addEventListener('click', (e) => {
                            if (e.target && e.target.classList.contains('layer-style-icon')) {
                                const layerName = e.target.dataset.layerName;
                                callbacks.onStyleIconClick(layerName);
                            }
                        });
                    }

                    // Dashboard Listeners
                    document.getElementById('back-to-map-btn').addEventListener('click', callbacks.onBackToMapClick);
                    document.getElementById('generate-chart-btn').addEventListener('click', callbacks.onGenerateChartClick);
                    document.getElementById('chart-type-select').addEventListener('change', callbacks.onChartTypeChange);
                    document.getElementById('segment-select').addEventListener('change', callbacks.onSegmentChange);
                },
                toggleDashboardView: (show) => {
                    if (show) {
                        container.classList.add('hidden');
                        dashboardView.classList.remove('hidden');
                    } else {
                        container.classList.remove('hidden');
                        dashboardView.classList.add('hidden');
                    }
                },
                setupDashboardControls: (columnNames) => {
                    const dimensionSelect = document.getElementById('dimension-select');
                    const segmentSelect = document.getElementById('segment-select');
                    dimensionSelect.innerHTML = '';
                    segmentSelect.innerHTML = '<option value="none">(None)</option>';

                    columnNames.forEach(name => {
                        const option1 = document.createElement('option');
                        option1.value = name;
                        option1.textContent = name;
                        dimensionSelect.appendChild(option1);

                        const option2 = document.createElement('option');
                        option2.value = name;
                        option2.textContent = name;
                        segmentSelect.appendChild(option2);
                    });
                    UIController.updateChartTypeOptions();
                },
                updateChartTypeOptions: () => {
                    const segmentSelect = document.getElementById('segment-select');
                    const chartTypeSelect = document.getElementById('chart-type-select');
                    const isSegmented = segmentSelect.value !== 'none';

                    if (isSegmented) {
                        // For segmented data, only allow bar charts
                        chartTypeSelect.innerHTML = `
                            <option value="stacked-bar">Stacked Bar</option>
                            <option value="bar">Grouped Bar</option>
                        `;
                    } else {
                        // For simple data, allow more types
                        chartTypeSelect.innerHTML = `
                            <option value="bar">Bar</option>
                            <option value="pie">Pie</option>
                            <option value="doughnut">Doughnut</option>
                        `;
                    }
                },
                addChartToGrid: (dimensionCol, segmentCol, chartType) => {
                    const grid = document.getElementById('chart-grid');
                    const chartId = `chart-canvas-${chartIdCounter++}`;

                    const card = document.createElement('div');
                    card.className = 'chart-card';
                    
                    let title = `Count of ${dimensionCol}`;
                    if(segmentCol !== 'none') {
                        title += ` by ${segmentCol}`;
                    }

                    card.innerHTML = `
                        <div class="chart-card-header">
                            <h3>${title}</h3>
                            <button class="remove-chart-btn" title="Remove Chart">❌</button>
                        </div>
                        <div class="chart-canvas-container">
                            <canvas id="${chartId}"></canvas>
                        </div>
                    `;
                    
                    grid.appendChild(card);
                    
                    const canvas = document.getElementById(chartId);
                    const success = AnalyticsController.createChart(canvas, State.getRawLocationData(), dimensionCol, segmentCol, chartType);
                    
                    if (!success) {
                        card.remove();
                        return;
                    }

                    card.querySelector('.remove-chart-btn').addEventListener('click', () => {
                        AnalyticsController.removeChart(chartId);
                        card.remove();
                    });
                },
                clearChartGrid: () => {
                    document.getElementById('chart-grid').innerHTML = '';
                    AnalyticsController.clearAllCharts();
                },
                showStyleEditor: (layerName, currentStyle, onApply) => {
                    document.getElementById('style-editor-title').textContent = `Style: ${layerName}`;
                    const colorPicker = document.getElementById('layer-color-picker');
                    const opacitySlider = document.getElementById('layer-opacity-slider');
                    
                    colorPicker.value = currentStyle.color || '#ff7800';
                    opacitySlider.value = currentStyle.fillOpacity;

                    const applyBtn = document.getElementById('apply-style-button');
                    const newApplyBtn = applyBtn.cloneNode(true);
                    applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
                    
                    newApplyBtn.onclick = () => {
                        const newOpacity = parseFloat(opacitySlider.value);
                        onApply(layerName, { color: colorPicker.value, opacity: 1, fillOpacity: newOpacity, weight: currentStyle.weight || 2 });
                        styleModal.classList.remove('visible');
                    };
                    styleModal.classList.add('visible');
                },
                showFieldConfigModal: (columnNames, currentConfig, onSave) => {
                    const body = document.getElementById('field-config-body');
                    body.innerHTML = `
                        <div class="field-config-header">
                            <div><a href="#" class="select-all-link" data-type="display" data-action="select">Select All</a> / <a href="#" class="select-all-link" data-type="display" data-action="deselect">Deselect All</a></div>
                            <div><a href="#" class="select-all-link" data-type="edit" data-action="select">Select All</a> / <a href="#" class="select-all-link" data-type="edit" data-action="deselect">Deselect All</a></div>
                        </div>`; 
                    const protectedFields = ['lat', 'latitude', 'lon', 'long', 'longitude', 'validation_status'];

                    columnNames.forEach(name => {
                        const isProtected = protectedFields.includes(name.toLowerCase().trim());
                        const row = document.createElement('div');
                        row.className = 'field-config-row';
                        const current = currentConfig[name];
                        row.innerHTML = `
                            <span class="field-name">${name}</span>
                            <div class="checkboxes">
                                <label><input type="checkbox" class="display-check" data-name="${name}" ${current.display ? 'checked' : ''} ${isProtected ? 'disabled' : ''}> Display</label>
                                <label><input type="checkbox" class="edit-check" data-name="${name}" ${current.editable ? 'checked' : ''} ${isProtected || !current.display ? 'disabled' : ''}> Edit</label>
                            </div>`;
                        body.appendChild(row);
                    });
                    
                    const autoSaveConfig = () => {
                        const newConfig = {};
                        body.querySelectorAll('.display-check').forEach(cb => {
                            const name = cb.dataset.name;
                            if (!newConfig[name]) newConfig[name] = { display: false, editable: false };
                            newConfig[name].display = cb.checked;
                        });
                        body.querySelectorAll('.edit-check').forEach(cb => {
                            const name = cb.dataset.name;
                            if (!newConfig[name]) newConfig[name] = { display: false, editable: false };
                            if(newConfig[name].display) newConfig[name].editable = cb.checked;
                            else newConfig[name].editable = false;
                        });
                        onSave(newConfig);
                    };

                    body.addEventListener('click', (e) => {
                        if (e.target.classList.contains('select-all-link')) {
                            e.preventDefault();
                            const type = e.target.dataset.type;
                            const action = e.target.dataset.action;
                            const isChecked = action === 'select';
                            body.querySelectorAll(`.${type}-check:not(:disabled)`).forEach(cb => cb.checked = isChecked);
                            if (type === 'display') {
                                body.querySelectorAll('.display-check').forEach(dcb => {
                                    const editCb = body.querySelector(`.edit-check[data-name="${dcb.dataset.name}"]`);
                                    if (!dcb.checked) { editCb.checked = false; editCb.disabled = true; } 
                                    else if(!editCb.hasAttribute('disabled')) { editCb.disabled = false; }
                                });
                            }
                            autoSaveConfig();
                        }
                    });

                    body.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.addEventListener('change', () => {
                            if (checkbox.classList.contains('display-check')) {
                                const editCb = body.querySelector(`.edit-check[data-name="${checkbox.dataset.name}"]`);
                                if (!checkbox.checked) { editCb.checked = false; editCb.disabled = true; } 
                                else { editCb.disabled = false; }
                            }
                            autoSaveConfig();
                        });
                    });
                    fieldConfigModal.classList.add('visible');
                },
                showInfoPanel: (point, onStatusChange, onFieldChange) => {
                    const fieldConfig = State.getFieldConfig();
                    let dataHtml = '';

                    const renderField = (key, value, recordIndex) => {
                        if (fieldConfig[key] && fieldConfig[key].display) {
                            if (fieldConfig[key].editable) {
                                return `<p><strong>${key}:</strong> <input type="text" class="editable-field" value="${value}" data-point-id="${point.id}" data-record-index="${recordIndex}" data-key="${key}"></p>`;
                            } else {
                                return `<p><strong>${key}:</strong> ${value}</p>`;
                            }
                        }
                        return '';
                    };

                    if (point.originalData.length > 1) {
                        point.originalData.forEach((rowData, index) => {
                            dataHtml += `<div class="stacked-point-header">Record ${index + 1} of ${point.originalData.length}</div>`;
                            for (const [key, value] of Object.entries(rowData)) {
                                dataHtml += renderField(key, value, index);
                            }
                        });
                    } else {
                        for (const [key, value] of Object.entries(point.originalData[0])) {
                            dataHtml += renderField(key, value, 0);
                        }
                    }

                    const title = point.originalData.length > 1 ? `Location Details (${point.originalData.length} records)` : 'Point Details';
                    infoPanel.innerHTML = `<h3>${title} <button id="info-panel-close" title="Close">&times;</button></h3><div id="info-panel-content">${dataHtml}</div><div class="rag-selector">
                        <button class="rag-button rag-green ${point.ragStatus === 'Green' ? 'selected' : ''}" data-status="Green">Green</button>
                        <button class="rag-button rag-amber ${point.ragStatus === 'Amber' ? 'selected' : ''}" data-status="Amber">Amber</button>
                        <button class="rag-button rag-red ${point.ragStatus === 'Red' ? 'selected' : ''}" data-status="Red">Red</button>
                        <button class="rag-button rag-not-required ${point.ragStatus === 'Not Required' ? 'selected' : ''}" data-status="Not Required">Not Required</button>
                    </div>`;
                    rightSidebar.classList.remove('hidden');
                    document.getElementById('info-panel-close').addEventListener('click', () => { rightSidebar.classList.add('hidden'); });
                    infoPanel.querySelector('.rag-selector').addEventListener('click', (e) => { if (e.target.classList.contains('rag-button')) { onStatusChange(point.id, e.target.dataset.status); } });
                    
                    infoPanel.querySelectorAll('.editable-field').forEach(input => {
                        input.addEventListener('change', (e) => {
                            onFieldChange(e.target.dataset.pointId, e.target.dataset.recordIndex, e.target.dataset.key, e.target.value);
                        });
                    });
                },
                updateInfoPanelStatus: (newStatus) => {
                    const selector = infoPanel.querySelector('.rag-selector');
                    if (!selector) return;
                    selector.querySelector('.selected')?.classList.remove('selected');
                    selector.querySelector(`[data-status="${newStatus}"]`)?.classList.add('selected');
                },
                updateStatsPanel: () => {
                    const points = State.getPoints();
                    const currentFilter = State.getCurrentFilter();
                    if (points.length === 0) { statsPanel.innerHTML = ''; return; }
                    const totalOriginalPoints = points.reduce((sum, p) => sum + p.originalData.length, 0);
                    const totalLocations = points.length;
                    const unvalidated = points.filter(p => p.ragStatus === 'Unvalidated').length;
                    const green = points.filter(p => p.ragStatus === 'Green').length;
                    const amber = points.filter(p => p.ragStatus === 'Amber').length;
                    const red = points.filter(p => p.ragStatus === 'Red').length;
                    const notRequired = points.filter(p => p.ragStatus === 'Not Required').length;

                    statsPanel.innerHTML = `
                        <h3>Validation Summary</h3>
                        <div class="stats-row ${currentFilter === 'All' ? 'active' : ''}" data-status="All"><span>Total Points:</span><span class="stats-value stats-total">${totalOriginalPoints}</span></div>
                        <div class="stats-row ${currentFilter === 'All' ? 'active' : ''}" data-status="All"><span>Unique Locations:</span><span class="stats-value stats-total">${totalLocations}</span></div>
                        <div class="stats-row ${currentFilter === 'Unvalidated' ? 'active' : ''}" data-status="Unvalidated"><span>Remaining (Unchecked):</span><span class="stats-value stats-unvalidated">${unvalidated}</span></div>
                        <div class="stats-row ${currentFilter === 'Green' ? 'active' : ''}" data-status="Green"><span>Green:</span><span class="stats-value stats-green">${green}</span></div>
                        <div class="stats-row ${currentFilter === 'Amber' ? 'active' : ''}" data-status="Amber"><span>Amber:</span><span class="stats-value stats-amber">${amber}</span></div>
                        <div class="stats-row ${currentFilter === 'Red' ? 'active' : ''}" data-status="Red"><span>Red:</span><span class="stats-value stats-red">${red}</span></div>
                        <div class="stats-row ${currentFilter === 'Not Required' ? 'active' : ''}" data-status="Not Required"><span>Not Required:</span><span class="stats-value stats-not-required">${notRequired}</span></div>
                        ${unvalidated > 0 ? '<button id="next-unchecked-btn" class="action-button">Go to Next Unchecked</button>' : '<p style="text-align:center; margin-top:10px; font-weight:bold; color:#28a745;">All locations validated!</p>'}`;
                },
                showLoader: (text = 'Loading...') => { loaderText.textContent = text; loader.classList.remove('hidden'); },
                hideLoader: () => { loader.classList.add('hidden'); },
                showToast: (message, type = 'info') => {
                    const container = document.getElementById('toast-container');
                    const toast = document.createElement('div');
                    toast.className = `toast ${type}`;
                    toast.textContent = message;
                    container.appendChild(toast);
                    setTimeout(() => toast.classList.add('show'), 10);
                    setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 4000);
                }
            };
        })();

        // --- GeminiAnalyzer.js ---
        const GeminiAnalyzer = (() => {
            const modal = document.getElementById('analysis-modal');
            const resultDiv = document.getElementById('analysis-result');
            
            const captureMapImage = async () => {
                const mapContainer = document.getElementById('map');
                const canvas = await html2canvas(mapContainer, { useCORS: true });
                return canvas.toDataURL('image/png').split(',')[1];
            };

            return {
                analyzeView: async (map) => {
                    resultDiv.innerHTML = '<p>Capturing map and preparing analysis...</p>';
                    modal.classList.add('visible');
                    
                    try {
                        const base64ImageData = await captureMapImage();
                        const bounds = map.getBounds();
                        const prompt = `You are an expert GIS analyst. Analyze the provided map image. The visible area is approximately bounded by:
                        Northeast: (${bounds.getNorthEast().lat.toFixed(4)}, ${bounds.getNorthEast().lng.toFixed(4)})
                        Southwest: (${bounds.getSouthWest().lat.toFixed(4)}, ${bounds.getSouthWest().lng.toFixed(4)}).
                        Provide a summary for a site suitability report. Describe the terrain (e.g., mountainous, flat, coastal), identify potential watershed features like rivers, valleys, or peaks. Based on the topography, suggest potential risks (e.g., steep slopes indicating landslide risk, low-lying areas for flood risk) and potential advantages (e.g., gentle slopes for construction, high points for communication towers).`;

                        const payload = {
                            contents: [{ role: "user", parts: [ { text: prompt }, { inlineData: { mimeType: "image/png", data: base64ImageData } } ] }],
                        };
                        
                        resultDiv.innerHTML = '<p>Contacting Gemini AI... this may take a moment.</p>';
                        const apiKey = "";
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                        const result = await response.json();
                        
                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts[0].text) {
                            const text = result.candidates[0].content.parts[0].text;
                            resultDiv.innerHTML = text.replace(/\n/g, '<br>');
                        } else { throw new Error("Invalid response structure from API."); }

                    } catch (error) {
                        console.error("Gemini analysis failed:", error);
                        resultDiv.innerHTML = `<p style="color: red;"><strong>Analysis Failed:</strong> ${error.message}.</p>`;
                    }
                },
                init: () => {
                    document.querySelectorAll('.modal').forEach(modal => {
                        modal.querySelector('.modal-close').addEventListener('click', () => modal.classList.remove('visible'));
                        modal.addEventListener('click', (e) => { if (e.target === modal) { modal.classList.remove('visible'); } });
                    });
                }
            };
        })();

        // --- app.js ---
        document.addEventListener('DOMContentLoaded', () => {
            const map = MapView.initializeMap();
            
            const onMarkerClick = (pointId) => {
                State.setCurrentIndexById(pointId);
                const point = State.getPointById(pointId);
                if (point) { MapView.setSelectedMarker(point); UIController.showInfoPanel(point, onStatusChange, onFieldChange); }
            };
            const onStatusChange = (pointId, newStatus) => {
                State.updatePointStatus(pointId, newStatus);
                const point = State.getPointById(pointId);
                if (point && point.mapMarker) { MapView.updateMarker(point.mapMarker, newStatus, true, point.originalData.length); }
                UIController.updateInfoPanelStatus(newStatus);
                UIController.updateStatsPanel();
            };
            const onFieldChange = (pointId, recordIndex, key, value) => {
                State.updatePointData(pointId, recordIndex, key, value);
                UIController.showToast("Data updated.", "success");
            };
            const onExportClick = () => {
                const points = State.getPoints();
                if (points.length === 0) { UIController.showToast("No data to export.", "error"); return; }
                Exporter.exportToCSV(points);
                UIController.showToast("Report exported successfully!", "success");
            };
            const onLocationFileSelect = (file) => {
                State.setLocationFile(file);
                document.getElementById('plot-button').disabled = true;
                UIController.showLoader('Reading location file...');
                const reader = new FileReader();
                const fileExtension = file.name.split('.').pop().toLowerCase();
                reader.onload = (e) => {
                    try {
                        let json;
                        if (fileExtension === 'csv') {
                            const csvText = new TextDecoder().decode(e.target.result);
                            const result = Papa.parse(csvText, { header: true, skipEmptyLines: false }); // Ensure we get headers even for empty rows
                            json = result.data;
                            // Post-process to ensure all headers are present on all objects, even if last rows are empty
                            if (json.length > 0) {
                                const headers = Object.keys(json[0]);
                                json = json.map(row => {
                                    const newRow = {};
                                    headers.forEach(h => newRow[h] = row[h] || '');
                                    return newRow;
                                });
                            }
                        } else {
                            const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[sheetName];
                            // Use sheet_to_json with defval to ensure empty cells become properties
                            json = XLSX.utils.sheet_to_json(worksheet, { defval: "" });
                        }
                        
                        State.setRawLocationData(json);

                        const headers = json.length > 0 ? Object.keys(json[0]) : [];
                        const configHeaders = [...headers];
                        if (!configHeaders.includes('User_Comment')) configHeaders.push('User_Comment');
                        
                        const initialConfig = {};
                        configHeaders.forEach(h => { initialConfig[h] = { display: true, editable: (h === 'User_Comment') } });
                        State.setFieldConfig(initialConfig);
                        document.getElementById('config-fields-button').classList.remove('hidden');

                        UIController.showToast("Location file loaded.", "success");
                        document.getElementById('plot-button').disabled = false;
                    } catch (err) {
                        console.error("File parsing error:", err);
                        UIController.showToast("Could not parse the location file.", "error");
                        State.setLocationFile(null);
                        document.getElementById('plot-button').disabled = true;
                        document.getElementById('config-fields-button').classList.add('hidden');
                    } finally { 
                        UIController.hideLoader(); 
                    }
                };
                reader.onerror = () => { 
                    UIController.showToast("Error reading file.", "error"); 
                    UIController.hideLoader(); 
                    document.getElementById('plot-button').disabled = true;
                };
                reader.readAsArrayBuffer(file);
            };
            const onGeoJsonFileSelect = (files) => {
                for (const file of files) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const geoJsonData = JSON.parse(e.target.result);
                            MapView.addGeoJsonLayer(map, geoJsonData, file.name);
                        } catch (error) {
                            console.error("Error parsing GeoJSON file:", error);
                            UIController.showToast(`Could not parse ${file.name}.`, 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            const onPlotClick = () => {
                State.setCurrentFilter('All'); 
                const rawData = State.getRawLocationData();
                if (!rawData) { UIController.showToast("Location data is not ready. Please re-select the file.", "error"); return; }
                UIController.showLoader('Processing points...');
                const pointsData = DataParser.parseLocationData(rawData);
                if (pointsData && pointsData.length > 0) {
                    State.setPoints(pointsData);
                    MapView.plotPoints(map, State.getPoints(), onMarkerClick);
                    UIController.updateStatsPanel();
                    UIController.showToast(`${pointsData.length} unique locations plotted.`, "success");
                } else { UIController.showToast("No valid location data found to plot.", "error"); }
                UIController.hideLoader();
            };
            const onStatusFilterClick = (status) => {
                State.setCurrentFilter(status);
                const allPoints = State.getPoints();
                const filteredPoints = status === 'All' ? allPoints : allPoints.filter(p => p.ragStatus === status);
                MapView.plotPoints(map, filteredPoints, onMarkerClick);
                UIController.updateStatsPanel();
            };
            const onNextUncheckedClick = () => {
                if (State.getCurrentFilter() !== 'Unvalidated') {
                    onStatusFilterClick('Unvalidated');
                }
                setTimeout(() => {
                    const nextPoint = State.findNextUnvalidated();
                    if (nextPoint) {
                        MapView.panToPoint(map, nextPoint);
                        MapView.setSelectedMarker(nextPoint);
                        UIController.showInfoPanel(nextPoint, onStatusChange, onFieldChange);
                    } else {
                        UIController.showToast("All points have been validated!", "success");
                    }
                }, 100);
            };
            const onAnalyzeClick = () => { GeminiAnalyzer.analyzeView(map); };
            
            const onInsightsClick = () => {
                const rawData = State.getRawLocationData();
                if (!rawData || rawData.length === 0) {
                    UIController.showToast("Please load a location file first.", "error");
                    return;
                }
                const columnNames = Object.keys(rawData[0]);
                UIController.setupDashboardControls(columnNames);
                UIController.toggleDashboardView(true);
            };
            const onBackToMapClick = () => {
                UIController.toggleDashboardView(false);
                UIController.clearChartGrid();
            };
            const onGenerateChartClick = () => {
                const dimensionCol = document.getElementById('dimension-select').value;
                const segmentCol = document.getElementById('segment-select').value;
                const chartType = document.getElementById('chart-type-select').value;
                UIController.addChartToGrid(dimensionCol, segmentCol, chartType);
            };
            const onChartTypeChange = () => {
                // This is handled by onSegmentChange now
            };
            const onSegmentChange = () => {
                UIController.updateChartTypeOptions();
            };

            const onStyleIconClick = (layerName) => {
                const currentStyle = MapView.getGeoJsonLayerStyle(layerName);
                if (currentStyle) {
                    UIController.showStyleEditor(layerName, currentStyle, (name, style) => {
                        MapView.updateGeoJsonStyle(name, style);
                        const layer = MapView.getGeoJsonLayer(name);
                        if (layer && !map.hasLayer(layer)) map.addLayer(layer);
                    });
                }
            };
            const onConfigFieldsClick = () => {
                const rawData = State.getRawLocationData();
                if (rawData && rawData.length > 0) {
                    const columnNames = Object.keys(State.getFieldConfig());
                    const currentConfig = State.getFieldConfig();
                    UIController.showFieldConfigModal(columnNames, currentConfig, (newConfig) => {
                        State.setFieldConfig(newConfig);
                        const rightSidebar = document.getElementById('right-sidebar');
                        const currentIndex = State.getCurrentIndex();
                        if (!rightSidebar.classList.contains('hidden') && currentIndex > -1) {
                            const currentPoint = State.getPoints()[currentIndex];
                            if(currentPoint) UIController.showInfoPanel(currentPoint, onStatusChange, onFieldChange);
                        }
                    });
                } else {
                    UIController.showToast("No location data loaded to configure.", "error");
                }
            };

            UIController.initializeUI({ 
                onMarkerClick, onExportClick, onLocationFileSelect, onPlotClick, 
                onNextUncheckedClick, onAnalyzeClick, onGeoJsonFileSelect, 
                onStyleIconClick, onConfigFieldsClick, onStatusFilterClick, 
                onInsightsClick, onBackToMapClick, onGenerateChartClick, onChartTypeChange, onSegmentChange
            });
            GeminiAnalyzer.init();
        });
    </script>
</body>
</html>
